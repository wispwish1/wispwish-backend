// import express from 'express';
// import aiService from '../services/aiService.js';
// import Gift from '../models/Gift.js';
// import Order from '../models/Order.js';
// import Payment from '../models/Payment.js';
// import nodemailerService from '../services/nodemailerService.js';
// import {authenticateToken} from '../middleware/auth.js';
// import VoiceStyle from '../models/VoiceStyle.js';

// const router = express.Router();

// // Debug logging for /generate route
// router.post('/generate', async (req, res) => {
//   try {
//     console.log('Received /api/gift/generate request:', JSON.stringify(req.body, null, 2));
    
//     const {
//       giftType,
//       recipientName,
//       tone,
//       memories,
//       relationship,
//       occasion,
//       senderMessage,
//       deliveryMethod,
//       deliveryEmail,
//       scheduledDate,
//       senderName,
//       buyerEmail, // Get buyer email from request body
//       voiceStyleId, // <-- accept from client
//     } = req.body;

//     // Generate content using AI service
//     const generatedContent = await aiService.generateContent({
//       giftType,
//       recipientName,
//       tone,
//       memories: memories || [],
//       relationship,
//       occasion,
//       voiceStyleId, // <-- pass along to service
//     });

//     console.log('Generated content:', generatedContent);

//     // Format the response for frontend consistency
//     let formattedContent = generatedContent;
//     if (giftType === 'voice' && generatedContent?.audio) {
//       // Convert base64 audio to data URL for frontend playback
//       formattedContent = {
//         text: generatedContent.text,
//         voiceMessage: {
//           script: generatedContent.text,
//           audioUrl: `data:audio/mpeg;base64,${generatedContent.audio}`,
//           duration: null // Duration not available from base64
//         }
//       };
//     }

//     const giftDoc = new Gift({
//       giftType,
//       recipientName,
//       senderName: senderName || 'Someone special',
//       tone,
//       memories: memories || [],
//       relationship: relationship || 'friend',
//       occasion: occasion || 'special occasion',
//       generatedContent: typeof formattedContent === 'object' ? formattedContent.text || formattedContent : formattedContent,
//       audioContent: typeof formattedContent === 'object' && formattedContent.voiceMessage ? formattedContent.voiceMessage.audioUrl : null,
//       senderMessage: senderMessage || '',
//       deliveryMethod: deliveryMethod || '',
//       deliveryEmail: deliveryEmail || '',
//       scheduledDate: scheduledDate ? new Date(scheduledDate) : undefined,
//       price: getPrice(giftType),
//       voiceStyleId: voiceStyleId || null, // <-- store selected voice style if provided
//     });

//     await giftDoc.save();
//     console.log('Gift saved with audioContent:', !!giftDoc.audioContent);

//     // Create payment and order (Handle both authenticated and non-authenticated users)
//     const userId = req.user?.id || null; // Optional user ID from authentication
//     const userEmail = req.user?.email || buyerEmail || 'guest@example.com';
//     const userName = req.user?.name || senderName || 'Guest User';
    
//     const payment = new Payment({
//       amount: giftDoc.price,
//       userId: userId,
//       method: 'stripe',
//       status: 'pending',
//       buyerEmail: userEmail,
//       buyerName: userName,
//     });
    
//     await payment.save();
    
//     const order = new Order({
//       userId: userId,
//       giftId: giftDoc._id,
//       type: giftType,
//       payment: payment._id,
//       paymentStatus: 'pending',
//       price: giftDoc.price
//     });
    
//     await order.save();

//     // Send order confirmation email to BUYER
//     try {
//       const buyerEmailAddress = userEmail;
//       if (buyerEmailAddress && buyerEmailAddress !== 'guest@example.com') {
//         console.log('Sending confirmation email to buyer:', buyerEmailAddress);
        
//         const emailResult = await nodemailerService.sendOrderConfirmation(buyerEmailAddress, {
//           orderId: order._id.toString().slice(-6),
//           giftType: giftType,
//           recipientName: recipientName,
//           recipientEmail: deliveryEmail,
//           price: giftDoc.price,
//           generatedContent: typeof formattedContent === 'object' ? formattedContent.text || formattedContent : formattedContent,
//           audioContent: formattedContent?.voiceMessage?.audioUrl, // Include audio for voice gifts
//           buyerName: userName
//         });
        
//         if (emailResult.success) {
//           console.log('Order confirmation email sent to buyer successfully:', emailResult.messageId);
//         } else {
//           console.error('Failed to send order confirmation email to buyer:', emailResult.error);
//         }
//       } else {
//         console.log('No valid buyer email available for confirmation');
//       }
//     } catch (emailError) {
//       console.error('Error sending order confirmation to buyer:', emailError);
//     }

//     // DON'T send gift delivery email here - only after payment is completed
//     // Gift email will be sent via payment webhook after successful payment
//     console.log('Gift created successfully. Gift email will be sent after payment completion.');
    
//     res.json({ giftId: giftDoc._id, generatedContent: formattedContent, orderId: order._id });
//   } catch (error) {
//     console.error('Error in /api/gift/generate:', error.message);
//     res.status(500).json({ message: error.message });
//   }
// });

// // Public: Get active voice styles (no voiceId exposure)
// router.get('/voice-styles', async (req, res) => {
//   try {
//     const styles = await VoiceStyle.find({ isActive: true })
//       .select('_id name gender accent isDefault previewUrl')
//       .sort({ isDefault: -1, createdAt: -1 });
//     res.json(styles);
//   } catch (error) {
//     console.error('Error fetching voice styles:', error);
//     res.status(500).json({ message: 'Failed to fetch voice styles' });
//   }
// });

// router.get('/:id', async (req, res) => {
//   console.log('Reached /api/gift/:id');
//   try {
//     const gift = await Gift.findById(req.params.id);
//     if (!gift) {
//       return res.status(404).json({ message: 'Gift not found' });
//     }
//     res.json(gift);
//   } catch (error) {
//     console.error('Error in /api/gift/:id:', error.message);
//     res.status(500).json({ message: error.message });
//   }
// });

// // Payment update route - this will send gift email after successful payment
// router.post('/update-payment/:orderId', async (req, res) => {
//   const { status } = req.body;
//   try {
//     const order = await Order.findById(req.params.orderId);
//     if (!order) {
//       return res.status(404).json({ message: 'Order not found' });
//     }

//     const payment = await Payment.findById(order.payment);
//     if (!payment) {
//       return res.status(404).json({ message: 'Payment not found' });
//     }

//     payment.status = status;
//     await payment.save();

//     order.paymentStatus = status;
//     await order.save();

//     const gift = await Gift.findById(order.giftId);
//     if (!gift) {
//       return res.status(404).json({ message: 'Gift not found' });
//     }

//     gift.paymentStatus = status;
//     await gift.save();

//     // ONLY send gift email after successful payment
//     if (status === 'completed' && gift.deliveryMethod === 'email' && gift.deliveryEmail) {
//       try {
//         const giftResult = await nodemailerService.sendGiftEmail({
//           giftType: gift.giftType,
//           recipientName: gift.recipientName,
//           senderMessage: gift.senderMessage,
//           generatedContent: gift.generatedContent,
//           scheduledDate: gift.scheduledDate,
//           deliveryEmail: gift.deliveryEmail,
//           occasion: gift.occasion,
//         });
        
//         if (giftResult.success) {
//           console.log('Gift email sent to recipient after payment:', giftResult.messageId);
//         } else {
//           console.error('Failed to send gift email after payment:', giftResult.error);
//         }
//       } catch (giftError) {
//         console.error('Error sending gift email after payment:', giftError);
//       }
//     }

//     res.json({ message: 'Payment status updated', order });
//   } catch (error) {
//     console.error('Error updating payment:', error);
//     res.status(500).json({ message: 'Server error' });
//   }
// });
// router.post('/create', async (req, res) => {
//   try {
//     const newGift = await Gift.create(req.body);
//     // Create associated payment
//     const payment = await Payment.create({
//       amount: newGift.price,
//       status: 'pending'
//     });

//     // Create associated order
//     const order = await Order.create({
//       giftId: newGift._id,
//       paymentStatus: 'pending',
//       payment: payment._id

//     });
//   } catch (error) {
//     console.error('Error updating payment:', error);
//     res.status(500).json({ message: 'Server error' });
//   }

//     // Optional authentication middleware
//     const optionalAuth = async (req, res, next) => {
//       try {
//         const authHeader = req.headers['authorization'];
//         const token = authHeader && authHeader.split(' ')[1];
        
//         if (token) {
//           const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');
//           const user = await User.findById(decoded.userId).select('-password');
//           if (user) {
//             req.user = user;
//           }
//         }
        
//         // Always proceed, even without auth
//         next();
//       } catch (error) {
//         // Continue without authentication
//         next();
//       }
//     };
    
//     // Update the route:
//     router.post('/generate', optionalAuth, async (req, res) => {
//       try {
//         // Generate content using AI service
//         const generatedContent = await aiService.generateContent({
//           giftType,
//           recipientName,
//           tone,
//           memories: memories || [],
//           relationship,
//           occasion,
//           voiceStyleId, // <-- pass along to service
//         });
    
//         console.log('Generated content:', generatedContent);
    
//         const giftDoc = new Gift({
//           giftType,
//           recipientName,
//           senderName: senderName || 'Someone special',
//           tone,
//           memories: memories || [],
//           relationship: relationship || 'friend',
//           occasion: occasion || 'special occasion',
//           generatedContent: typeof generatedContent === 'object' ? generatedContent.text : generatedContent,
//           audioContent: typeof generatedContent === 'object' && generatedContent.audio ? generatedContent.audio : null,
//           senderMessage: senderMessage || '',
//           deliveryMethod: deliveryMethod || '',
//           deliveryEmail: deliveryEmail || '',
//           scheduledDate: scheduledDate ? new Date(scheduledDate) : undefined,
//           price: getPrice(giftType),
//           voiceStyleId: voiceStyleId || null, // <-- store selected voice style if provided
//         });
    
//         await giftDoc.save();
//         console.log('Gift saved with audioContent:', !!giftDoc.audioContent);
    
//         // Create payment and order (FIXED: Use real user ID from authentication)
//         const userId = req.user.id; // Real user ID from authentication middleware
        
//         const payment = new Payment({
//           amount: giftDoc.price,
//           userId: userId, // Using real user ID instead of dummy
//           method: 'stripe',
//           status: 'pending',
//           buyerEmail: req.user.email, // Add required buyerEmail
//           buyerName: req.user.name || senderName || 'Unknown', // Add required buyerName
//         });
        
//         await payment.save();
        
//         const order = new Order({
//           userId: userId, // Using real user ID instead of dummy
//           giftId: giftDoc._id,
//           type: giftType,
//           payment: payment._id,
//           paymentStatus: 'pending',
//           price: giftDoc.price
//         });
        
//         await order.save();
    
//         // Send order confirmation email to BUYER (logged-in user)
//         try {
//           // FIXED: Use authenticated user's email properly
//           const buyerEmailAddress = req.user.email; // Get buyer email from authenticated user
//           console.log('Sending confirmation email to buyer:', buyerEmailAddress);
          
//           const emailResult = await nodemailerService.sendOrderConfirmation(buyerEmailAddress, {
//             orderId: order._id.toString().slice(-6),
//             giftType: giftType,
//             recipientName: recipientName,
//             recipientEmail: deliveryEmail,
//             price: giftDoc.price,
//             generatedContent: typeof generatedContent === 'object' ? generatedContent.text : generatedContent,
//             buyerName: req.user.name || 'Friend', // Add buyer name if available
//             audioContent: giftDoc.audioContent // Add audioContent here
//           });
          
//           if (emailResult.success) {
//             console.log('Order confirmation email sent to buyer successfully:', emailResult.messageId);
//           } else {
//             console.error('Failed to send order confirmation email to buyer:', emailResult.error);
//           }
//         } catch (emailError) {
//           console.error('Error sending order confirmation to buyer:', emailError);
//         }
    
//         // DON'T send gift delivery email here - only after payment is completed
//         // Gift email will be sent via payment webhook after successful payment
//         console.log('Gift created successfully. Gift email will be sent after payment completion.');
        
//         res.json({ giftId: giftDoc._id, generatedContent, orderId: order._id });
//       } catch (error) {
//         console.error('Error in /api/gift/generate:', error.message);
//         res.status(500).json({ message: error.message });
//       }
//     });
    
//     // Use authenticated user if available, otherwise use guest
//     const userId = req.user?.id || 'guest';
//     const userEmail = req.user?.email || req.body.buyerEmail || 'guest@example.com';
//     const userName = req.user?.name || req.body.senderName || 'Guest';
    
//     // Send order confirmation email to BUYER (logged-in user)
//     try {
//       // FIXED: Use authenticated user's email properly
//       const buyerEmailAddress = req.user.email; // Get buyer email from authenticated user
//       console.log('Sending confirmation email to buyer:', buyerEmailAddress);
      
//       const emailResult = await nodemailerService.sendOrderConfirmation(buyerEmailAddress, {
//         orderId: order._id.toString().slice(-6),
//         giftType: giftType,
//         recipientName: recipientName,
//         recipientEmail: deliveryEmail,
//         price: giftDoc.price,
//         generatedContent: typeof generatedContent === 'object' ? generatedContent.text : generatedContent,
//         buyerName: req.user.name || 'Friend' // Add buyer name if available
//       });
      
//       if (emailResult.success) {
//         console.log('Order confirmation email sent to buyer successfully:', emailResult.messageId);
//       } else {
//         console.error('Failed to send order confirmation email to buyer:', emailResult.error);
//       }
    
//     //  catch (emailError) {
//     //   console.error('Error sending order confirmation to buyer:', emailError);
//     // }


//     // DON'T send gift delivery email here - only after payment is completed
//     // Gift email will be sent via payment webhook after successful payment
//     console.log('Gift created successfully. Gift email will be sent after payment completion.');
    
//     res.json({ giftId: giftDoc._id, generatedContent, orderId: order._id });
  
//     // DON'T send gift delivery email here - only after payment is completed
//     // Gift email will be sent via payment webhook after successful payment
//     console.log('Gift created successfully. Gift email will be sent after payment completion.');
    
//     res.json({ giftId: giftDoc._id, generatedContent, orderId: order._id });
//   } catch (error) {
//     console.error('Error in /api/gift/generate:', error.message);
//     res.status(500).json({ message: error.message });
//   }
// });

// // Public: Get active voice styles (no voiceId exposure)
// router.get('/voice-styles', async (req, res) => {
//   try {
//     const styles = await VoiceStyle.find({ isActive: true })
//       .select('_id name gender accent isDefault previewUrl')
//       .sort({ isDefault: -1, createdAt: -1 });
//     res.json(styles);
//   } catch (error) {
//     console.error('Error fetching voice styles:', error);
//     res.status(500).json({ message: 'Failed to fetch voice styles' });
//   }
// });

// router.get('/:id', async (req, res) => {
//   console.log('Reached /api/gift/:id');
//   try {
//     const gift = await Gift.findById(req.params.id);
//     if (!gift) {
//       return res.status(404).json({ message: 'Gift not found' });
//     }
//     res.json(gift);
//   } catch (error) {
//     console.error('Error in /api/gift/:id:', error.message);
//     res.status(500).json({ message: error.message });
//   }
// });

// function getPrice(giftType) {
//   switch (giftType) {
//     case 'voice': return 12;
//     case 'song': return 25;
//     case 'image': return 15;
//     case 'illustration': return 15;  // New illustration support
//     case 'video': return 18;         // New video support  
//     case 'poem': return 8;
//     case 'wishknot': return 9;
//     case 'letter': return 8;
//     case 'shortStory': return 10;
//     default: return 8;
//   }
// }

// // After saving order and payment:
// // await nodemailerService.sendOrderConfirmation(buyerEmail, {
// //   orderId: order._id.toString().slice(-6),
// //   giftType,
// //   recipientName,
// //   recipientEmail: deliveryEmail,
// //   price: giftDoc.price,
// //   generatedContent
// // });

// // if (payment.status === 'paid' && deliveryEmail) {
// //   await nodemailerService.sendGiftEmail(deliveryEmail, {
// //     giftType,
// //     recipientName,
// //     senderMessage,
// //     generatedContent,
// //     scheduledDate
// //   });
// // }

// // In /generate route, after saving order:
// // Remove or comment out the immediate gift sending
// // if (deliveryMethod === 'email' && deliveryEmail) {
// //   try {
// //     const giftResult = await nodemailerService.sendGiftEmail(deliveryEmail, {
// //       giftType: giftType,
// //       recipientName: recipientName,
// //       senderMessage: senderMessage,
// //       generatedContent: generatedContent,
// //       scheduledDate: scheduledDate
// //     });
// //     
// //     if (giftResult.success) {
// //       console.log('Gift email sent to recipient successfully:', giftResult.messageId);
// //     } else {
// //       console.error('Failed to send gift email to recipient:', giftResult.error);
// //     }
// //   } catch (giftError) {
// //     console.error('Error sending gift email to recipient:', giftError);
// //   }
// // }

// // New route for updating payment status
// // router.post('/update-payment/:orderId', async (req, res) => {
// //   const { status } = req.body;
// //   try {
// //     const order = await Order.findById(req.params.orderId);
// //     if (!order) {
// //       return res.status(404).json({ message: 'Order not found' });
// //     }

// //     const payment = await Payment.findById(order.payment);
// //     if (!payment) {
// //       return res.status(404).json({ message: 'Payment not found' });
// //     }

// //     payment.status = status;
// //     await payment.save();

// //     order.paymentStatus = status;
// //     await order.save();

// //     const gift = await Gift.findById(order.giftId);
// //     if (!gift) {
// //       return res.status(404).json({ message: 'Gift not found' });
// //     }

// //     gift.paymentStatus = status;
// //     await gift.save();

// //     if (status === 'completed' && gift.deliveryMethod === 'email' && gift.deliveryEmail) {
// //       try {
// //         const giftResult = await nodemailerService.sendGiftEmail(gift.deliveryEmail, {
// //           giftType: gift.giftType,
// //           recipientName: gift.recipientName,
// //           senderMessage: gift.senderMessage,
// //           generatedContent: gift.generatedContent,
// //           scheduledDate: gift.scheduledDate
// //         });
        
// //         if (giftResult.success) {
// //           console.log('Gift email sent to recipient after payment:', giftResult.messageId);
// //         } else {
// //           console.error('Failed to send gift email after payment:', giftResult.error);
// //         }
// //       } catch (giftError) {
// //         console.error('Error sending gift email after payment:', giftError);
// //       }
// //     }

// //     res.json({ message: 'Payment status updated', order });
// //   } catch (error) {
// //     console.error('Error updating payment:', error);
// //     res.status(500).json({ message: 'Server error' });
// //   }
// // });

// // Payment update route - this will send gift email after successful payment
// router.post('/update-payment/:orderId', async (req, res) => {
//   const { status } = req.body;
//   try {
//     const order = await Order.findById(req.params.orderId);
//     if (!order) {
//       return res.status(404).json({ message: 'Order not found' });
//     }

//     const payment = await Payment.findById(order.payment);
//     if (!payment) {
//       return res.status(404).json({ message: 'Payment not found' });
//     }

//     payment.status = status;
//     await payment.save();

//     order.paymentStatus = status;
//     await order.save();

//     const gift = await Gift.findById(order.giftId);
//     if (!gift) {
//       return res.status(404).json({ message: 'Gift not found' });
//     }

//     gift.paymentStatus = status;
//     await gift.save();

//     // ONLY send gift email after successful payment
//     if (status === 'completed' && gift.deliveryMethod === 'email' && gift.deliveryEmail) {
//       try {
//         const giftResult = await nodemailerService.sendGiftEmail({
//           giftType: gift.giftType,
//           recipientName: gift.recipientName,
//           senderMessage: gift.senderMessage,
//           generatedContent: gift.generatedContent,
//           scheduledDate: gift.scheduledDate,
//           deliveryEmail: gift.deliveryEmail,
//           occasion: gift.occasion,
//         });
        
//         if (giftResult.success) {
//           console.log('Gift email sent to recipient after payment:', giftResult.messageId);
//         } else {
//           console.error('Failed to send gift email after payment:', giftResult.error);
//         }
//       } catch (giftError) {
//         console.error('Error sending gift email after payment:', giftError);
//       }
//     }

//     res.json({ message: 'Payment status updated', order });
//   } catch (error) {
//     console.error('Error updating payment:', error);
//     res.status(500).json({ message: 'Server error' });
//   }
// });

// // Check RunwayML account status
// router.get('/runway-status', async (req, res) => {
//   try {
//     if (!process.env.RUNWAY_API_KEY || process.env.RUNWAY_API_KEY === 'your_runway_api_key_here') {
//       return res.json({ 
//         status: 'not_configured',
//         message: 'RunwayML API key not configured'
//       });
//     }
    
//     // Try to get account info
//     const response = await axios.get('https://api.dev.runwayml.com/v1/account', {
//       headers: {
//         'Authorization': `Bearer ${process.env.RUNWAY_API_KEY}`,
//         'X-Runway-Version': '2024-11-06',
//       },
//       timeout: 10000
//     });
    
//     res.json({
//       status: 'active',
//       account: response.data,
//       message: 'RunwayML API is working'
//     });
//   } catch (error) {
//     console.error('RunwayML status check failed:', error.message);
//     res.json({
//       status: 'error',
//       error: error.response?.data?.error || error.message,
//       message: 'RunwayML API check failed'
//     });
//   }
// });











import express from 'express';
import axios from 'axios';
import aiService from '../services/aiService.js';
import Gift from '../models/Gift.js';
import Order from '../models/Order.js';
import Payment from '../models/Payment.js';
import nodemailerService from '../services/nodemailerService.js';
import jwt from 'jsonwebtoken'; // Added for optionalAuth middleware
import User from '../models/User.js'; // Added for optionalAuth middleware
import VoiceStyle from '../models/VoiceStyle.js';
import WishKnot from '../models/WishKnot.js'; // Add WishKnot model

const router = express.Router();

// Optional authentication middleware
const optionalAuth = async (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token) {
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');
      const user = await User.findById(decoded.userId).select('-password');
      if (user) {
        req.user = user;
      }
    }

    // Always proceed, even without auth
    next();
  } catch (error) {
    // Continue without authentication
    next();
  }
};

// Generate gift route
router.post('/generate', optionalAuth, async (req, res) => {
  try {
    console.log('Received /api/gift/generate request:', JSON.stringify(req.body, null, 2));

    const {
      giftType,
      recipientName,
      tone,
      memories,
      relationship,
      occasion,
      senderMessage,
      deliveryMethod,
      deliveryEmail,
      scheduledDate,
      senderName,
      buyerEmail,
      voiceStyleId,
    } = req.body;

    // Handle combo gift type (Full Experience) - generate all components
    let generatedContent;
    if (giftType === 'combo') {
      console.log('ðŸŽ¨ Generating Full Experience (combo) gift with all components...');
      
      // Generate all components for combo gift
      const [poemContent, voiceContent, illustrationContent, videoContent] = await Promise.all([
        aiService.generateContent({
          giftType: 'poem',
          recipientName,
          tone,
          memories: memories || [],
          relationship,
          occasion
        }),
        aiService.generateContent({
          giftType: 'voice',
          recipientName,
          tone,
          memories: memories || [],
          relationship,
          occasion
        }),
        aiService.generateContent({
          giftType: 'illustration',
          recipientName,
          tone,
          memories: memories || [],
          relationship,
          occasion
        }),
        aiService.generateContent({
          giftType: 'video',
          recipientName,
          tone,
          memories: memories || [],
          relationship,
          occasion
        })
      ]);
      
      // Combine all content into a single response
      generatedContent = {
        type: 'combo',
        poem: poemContent,
        voice: voiceContent,
        illustration: illustrationContent,
        video: videoContent,
        text: `Full Experience Gift for ${recipientName}`,
        isCombo: true
      };
      
      console.log('âœ… Full Experience gift generated with all components');
    } else {
      // Generate content using AI service for single gift types
      generatedContent = await aiService.generateContent({
        giftType,
        recipientName,
        tone,
        memories: memories || [],
        relationship,
        occasion,
        voiceStyleId,
      });
    }

    console.log('Generated content:', generatedContent);

    // Format the response for frontend consistency (handle voice/video/wishknot/combo)
    let formattedContent = generatedContent;
    if (giftType === 'combo' && generatedContent?.isCombo) {
      // Format combo content with all components
      formattedContent = {
        text: generatedContent.text,
        type: 'combo',
        isCombo: true,
        components: {
          poem: typeof generatedContent.poem === 'object' ? generatedContent.poem : { text: generatedContent.poem },
          voice: generatedContent.voice,
          illustration: generatedContent.illustration,
          video: generatedContent.video
        }
      };
    } else if (giftType === 'voice' && generatedContent?.audio) {
      const audioUrl = `data:audio/mpeg;base64,${generatedContent.audio}`;
      formattedContent = {
        text: generatedContent.text,
        audioUrl: audioUrl, // Added top-level audioUrl for frontend simplicity
        voiceMessage: {
          script: generatedContent.text,
          audioUrl: audioUrl,
          duration: null // Duration not available from base64
        }
      };
    } else if (giftType === 'video' && generatedContent?.video) {
      const videoUrl = `data:video/mp4;base64,${generatedContent.video}`;
      formattedContent = {
        text: generatedContent.text,
        videoUrl: videoUrl, // Added top-level videoUrl for frontend simplicity
        videoMessage: {
          script: generatedContent.text,
          videoUrl: videoUrl,
          duration: null // Duration not available from base64
        }
      };
    } else if (giftType === 'wishknot' && generatedContent?.wishknot) {
      const wishknotUrl = `data:image/png;base64,${generatedContent.wishknot}`;
      formattedContent = {
        text: generatedContent.text,
        wishknotUrl: wishknotUrl, // Added top-level wishknotUrl for frontend simplicity
        wishknotMessage: {
          script: generatedContent.text,
          wishknotUrl: wishknotUrl,
          duration: null // Duration not available from base64
        }
      };
    }

    const giftDoc = new Gift({
      giftType,
      recipientName,
      senderName: senderName || 'Someone special',
      tone,
      memories: memories || [],
      relationship: relationship || 'friend',
      occasion: occasion || 'special occasion',
      generatedContent: typeof formattedContent === 'object' ? formattedContent.text || formattedContent : formattedContent,
      audioContent: typeof formattedContent === 'object' && formattedContent.audioUrl ? formattedContent.audioUrl : null,
      videoContent: typeof formattedContent === 'object' && formattedContent.videoUrl ? formattedContent.videoUrl : null,
      wishknotContent: typeof formattedContent === 'object' && formattedContent.wishknotUrl ? formattedContent.wishknotUrl : null,
      senderMessage: senderMessage || '',
      deliveryMethod: deliveryMethod || '',
      deliveryEmail: deliveryEmail || '',
      scheduledDate: scheduledDate ? new Date(scheduledDate) : undefined,
      price: getPrice(giftType),
      voiceStyleId: voiceStyleId || null, // <-- store selected voice style if provided
    });

    await giftDoc.save();
    console.log('Gift saved with audioContent:', !!giftDoc.audioContent);

    // Create payment and order (Handle both authenticated and non-authenticated users)
    const userId = req.user?.id || null; // Optional user ID from authentication
    const userEmail = req.user?.email || buyerEmail || 'guest@example.com';
    const userName = req.user?.name || senderName || 'Guest User';
    
    const payment = new Payment({
      amount: giftDoc.price,
      userId: userId,
      method: 'stripe',
      status: 'pending',
      buyerEmail: userEmail,
      buyerName: userName,
    });
    
    await payment.save();
    
    const order = new Order({
      userId: userId,
      giftId: giftDoc._id,
      type: giftType,
      payment: payment._id,
      paymentStatus: 'pending',
      price: giftDoc.price
    });
    
    await order.save();

    // Send order confirmation email to BUYER
    try {
      const buyerEmailAddress = userEmail;
      if (buyerEmailAddress && buyerEmailAddress !== 'guest@example.com') {
        console.log('Sending confirmation email to buyer:', buyerEmailAddress);
        
        const emailResult = await nodemailerService.sendOrderConfirmation(buyerEmailAddress, {
          orderId: order._id.toString().slice(-6),
          giftType: giftType,
          recipientName: recipientName,
          recipientEmail: deliveryEmail,
          price: giftDoc.price,
          generatedContent: typeof formattedContent === 'object' ? formattedContent.text || formattedContent : formattedContent,
          audioContent: formattedContent?.voiceMessage?.audioUrl, // Include audio for voice gifts
          buyerName: userName
        });
        
        if (emailResult.success) {
          console.log('Order confirmation email sent to buyer successfully:', emailResult.messageId);
        } else {
          console.error('Failed to send order confirmation email to buyer:', emailResult.error);
        }
      } else {
        console.log('No valid buyer email available for confirmation');
      }
    } catch (emailError) {
      console.error('Error sending order confirmation to buyer:', emailError);
    }

    // DON'T send gift delivery email here - only after payment is completed
    // Gift email will be sent via payment webhook after successful payment
    console.log('Gift created successfully. Gift email will be sent after payment completion.');
    
    res.json({ giftId: giftDoc._id, generatedContent: formattedContent, orderId: order._id });
  } catch (error) {
    console.error('Error in /api/gift/generate:', error.message);
    res.status(500).json({ message: error.message });
  }
});

// Public: Get active voice styles (no voiceId exposure)
router.get('/voice-styles', async (req, res) => {
  try {
    const styles = await VoiceStyle.find({ isActive: true })
      .select('_id name gender accent isDefault previewUrl')
      .sort({ isDefault: -1, createdAt: -1 });
    res.json(styles);
  } catch (error) {
    console.error('Error fetching voice styles:', error);
    res.status(500).json({ message: 'Failed to fetch voice styles' });
  }
});

router.get('/:id', async (req, res) => {
  console.log('Reached /api/gift/:id');
  try {
    const gift = await Gift.findById(req.params.id);
    if (!gift) {
      return res.status(404).json({ message: 'Gift not found' });
    }
    res.json(gift);
  } catch (error) {
    console.error('Error in /api/gift/:id:', error.message);
    res.status(500).json({ message: error.message });
  }
});

// Payment update route - this will send gift email after successful payment
router.post('/update-payment/:orderId', async (req, res) => {
  const { status } = req.body;
  try {
    const order = await Order.findById(req.params.orderId);
    if (!order) {
      return res.status(404).json({ message: 'Order not found' });
    }

    const payment = await Payment.findById(order.payment);
    if (!payment) {
      return res.status(404).json({ message: 'Payment not found' });
    }

    payment.status = status;
    await payment.save();

    order.paymentStatus = status;
    await order.save();

    const gift = await Gift.findById(order.giftId);
    if (!gift) {
      return res.status(404).json({ message: 'Gift not found' });
    }

    gift.paymentStatus = status;
    await gift.save();

    // ONLY send gift email after successful payment
    if (status === 'completed' && gift.deliveryMethod === 'email' && gift.deliveryEmail) {
      try {
        const giftResult = await nodemailerService.sendGiftEmail({
          giftType: gift.giftType,
          recipientName: gift.recipientName,
          senderMessage: gift.senderMessage,
          generatedContent: gift.generatedContent,
          scheduledDate: gift.scheduledDate,
          deliveryEmail: gift.deliveryEmail,
          occasion: gift.occasion,
        });
        
        if (giftResult.success) {
          console.log('Gift email sent to recipient after payment:', giftResult.messageId);
        } else {
          console.error('Failed to send gift email after payment:', giftResult.error);
        }
    } else if (giftType === 'video' && (generatedContent?.videoUrl || generatedContent?.error)) {
      formattedContent = {
        text: generatedContent.text || generatedContent.script,
        videoUrl: generatedContent.videoUrl,
        script: generatedContent.script || generatedContent.text,
        description: generatedContent.description || `Video tribute content for ${recipientName}`,
        error: generatedContent.error || null,
        type: 'video'
      };
    } else if (giftType === 'wishknot' && (generatedContent?.animationUrl || generatedContent?.message)) {
      // For WishKnot, we store placeholder in Gift.generatedContent for security
      // But we return the actual message in response for creator preview
      formattedContent = {
        text: 'WishKnot created successfully - message stored securely',
        animationUrl: generatedContent.animationUrl || null,
        knotType: generatedContent.knotType || 'Heart Knot',
        message: generatedContent.message || generatedContent.text || 'Your personalized message has been created', // Return actual message for creator preview
        previewMessage: generatedContent.message || generatedContent.text, // Add preview field for frontend
        isWishKnot: true // Flag to identify WishKnot content
      };
    }

    console.log('Formatted content for response:', formattedContent); // Debug log

    const giftDoc = new Gift({
      giftType,
      recipientName,
      senderName: senderName || 'Someone special',
      tone,
      memories: memories || [],
      relationship: relationship || 'friend',
      occasion: occasion || 'special occasion',
      generatedContent: typeof formattedContent === 'object' ? formattedContent.text || formattedContent : formattedContent,
      audioContent: formattedContent?.voiceMessage?.audioUrl || null,
      videoContent: formattedContent?.videoUrl || null, // Add video content
      senderMessage: senderMessage || '',
      deliveryMethod: deliveryMethod || '',
      deliveryEmail: deliveryEmail || '',
      scheduledDate: scheduledDate ? new Date(scheduledDate) : undefined,
      price: getPrice(giftType),
      voiceStyleId: voiceStyleId || null,
    });

    await giftDoc.save();
    console.log('Gift saved with audioContent:', !!giftDoc.audioContent);
    
    // Create WishKnot record for WishKnot gifts
    let wishKnotData = null;
    if (giftType === 'wishknot' && formattedContent) {
      try {
        console.log('ðŸª¢ Creating WishKnot record...');
        
        const wishKnot = new WishKnot({
          giftId: giftDoc._id,
          senderName: senderName || 'Someone special',
          recipientName,
          recipientEmail: deliveryEmail,
          personalizedMessage: generatedContent.message || generatedContent.text, // Use original generatedContent, not formattedContent
          tiedAnimationUrl: formattedContent.animationUrl,
          untieAnimationUrl: formattedContent.untieAnimationUrl || formattedContent.animationUrl,
          knotType: formattedContent.knotType || 'Heart Knot',
          tone,
          relationship: relationship || 'friend',
          occasion: occasion || 'special occasion',
          senderMessage,
          scheduledRevealDate: scheduledDate ? new Date(scheduledDate) : null,
          visualMetadata: formattedContent.metadata || {}
        });
        
        await wishKnot.save();
        
        wishKnotData = {
          knotId: wishKnot.knotId,
          accessToken: wishKnot.accessToken,
          viewUrl: `/api/wishknot/view/${wishKnot.accessToken}`,
          untieUrl: `/api/wishknot/untie/${wishKnot.accessToken}`
        };
        
        console.log('âœ… WishKnot record created successfully:', wishKnot.knotId);
      } catch (wishKnotError) {
        console.error('âŒ Error creating WishKnot record:', wishKnotError.message);
        // Continue with gift creation even if WishKnot fails
      }
    }

    // Use authenticated user if available, otherwise use guest
    const userId = req.user?.id || null;
    const userEmail = req.user?.email || buyerEmail || 'guest@example.com';
    const userName = req.user?.name || senderName || 'Guest';

    const payment = new Payment({
      amount: giftDoc.price,
      userId,
      method: 'stripe',
      status: 'pending',
      buyerEmail: userEmail,
      buyerName: userName,
    });

    await payment.save();

    const order = new Order({
      userId,
      giftId: giftDoc._id,
      type: giftType,
      payment: payment._id,
      paymentStatus: 'pending',
      price: giftDoc.price
    });

    await order.save();

    // Send order confirmation email to BUYER
    try {
      if (userEmail && userEmail !== 'guest@example.com') {
        console.log('Sending confirmation email to buyer:', userEmail);
        const emailResult = await nodemailerService.sendOrderConfirmation(userEmail, {
          orderId: order._id.toString().slice(-6),
          giftType,
          recipientName,
          recipientEmail: deliveryEmail,
          price: giftDoc.price,
          generatedContent: typeof formattedContent === 'object' ? formattedContent.text || formattedContent : formattedContent,
          audioContent: formattedContent?.voiceMessage?.audioUrl || null,
          buyerName: userName,
          giftId: giftDoc._id // Add giftId for WishKnot message lookup
        });

        if (emailResult.success) {
          console.log('Order confirmation email sent to buyer successfully:', emailResult.messageId);
        } else {
          console.error('Failed to send order confirmation email to buyer:', emailResult.error);
        }
      } else {
        console.log('No valid buyer email available for confirmation');
      }
    } catch (emailError) {
      console.error('Error sending order confirmation to buyer:', emailError);
    }

    console.log('Gift created successfully. Gift email will be sent after payment completion.');

    // Return response with giftId, formattedContent, orderId, and WishKnot data
    const response = { 
      giftId: giftDoc._id, 
      generatedContent: formattedContent, 
      orderId: order._id 
    };
    
    // Add WishKnot specific data if applicable
    if (wishKnotData) {
      response.wishKnot = wishKnotData;
    }
    
    res.json(response);
  } catch (error) {
    console.error('Error in /api/gift/generate:', error.message);
    res.status(500).json({ message: error.message });
  }
});

// Create gift route
router.post('/create', async (req, res) => {
  try {
    const newGift = await Gift.create(req.body);

    const payment = await Payment.create({
      amount: newGift.price,
      status: 'pending'
    });

    const order = await Order.create({
      giftId: newGift._id,
      paymentStatus: 'pending',
      payment: payment._id
    });

    res.json({ giftId: newGift._id, orderId: order._id });
  } catch (error) {
    console.error('Error creating gift:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get active voice styles
router.get('/voice-styles', async (req, res) => {
  try {
    const styles = await VoiceStyle.find({ isActive: true })
      .select('_id name gender accent isDefault previewUrl')
      .sort({ isDefault: -1, createdAt: -1 });
    res.json(styles);
  } catch (error) {
    console.error('Error fetching voice styles:', error);
    res.status(500).json({ message: 'Failed to fetch voice styles' });
  }
});

// Get gift by ID
router.get('/:id', async (req, res) => {
  console.log('Reached /api/gift/:id');
  try {
    const gift = await Gift.findById(req.params.id);
    if (!gift) {
      return res.status(404).json({ message: 'Gift not found' });
    }
    res.json(gift);
  } catch (error) {
    console.error('Error in /api/gift/:id:', error.message);
    res.status(500).json({ message: error.message });
  }
});

// Update payment status
router.post('/update-payment/:orderId', async (req, res) => {
  const { status } = req.body;
  try {
    const order = await Order.findById(req.params.orderId);
    if (!order) {
      return res.status(404).json({ message: 'Order not found' });
    }

    const payment = await Payment.findById(order.payment);
    if (!payment) {
      return res.status(404).json({ message: 'Payment not found' });
    }

    payment.status = status;
    await payment.save();

    order.paymentStatus = status;
    await order.save();

    const gift = await Gift.findById(order.giftId);
    if (!gift) {
      return res.status(404).json({ message: 'Gift not found' });
    }

    gift.paymentStatus = status;
    await gift.save();

    // Send gift email after successful payment
    if (status === 'completed' && gift.deliveryMethod === 'email' && gift.deliveryEmail) {
      try {
        // Handle WishKnot email differently
        if (gift.giftType === 'wishknot') {
          // Find the associated WishKnot record
          const wishKnot = await WishKnot.findOne({ giftId: gift._id });
          
          if (wishKnot) {
            const wishKnotEmailResult = await nodemailerService.sendWishKnotEmail({
              recipientEmail: gift.deliveryEmail,
              recipientName: gift.recipientName,
              senderName: gift.senderName,
              knotType: wishKnot.knotType,
              occasion: gift.occasion,
              giftId: gift._id,
              accessToken: wishKnot.accessToken,
              viewUrl: `${process.env.BASE_URL || 'http://127.0.0.1:5500'}/wishknot-view.html?giftId=${gift._id}&token=${wishKnot.accessToken}`,
              scheduledRevealDate: wishKnot.scheduledRevealDate
            });
            
            if (wishKnotEmailResult.success) {
              console.log('WishKnot email sent to recipient after payment:', wishKnotEmailResult.messageId);
              await wishKnot.logInteraction('email_sent', { recipientEmail: gift.deliveryEmail });
            } else {
              console.error('Failed to send WishKnot email after payment:', wishKnotEmailResult.error);
            }
          } else {
            console.error('WishKnot record not found for gift:', gift._id);
          }
        } else {
          // Send regular gift email for other gift types
          const giftResult = await nodemailerService.sendGiftEmail({
            giftType: gift.giftType,
            recipientName: gift.recipientName,
            senderMessage: gift.senderMessage,
            generatedContent: gift.generatedContent,
            audioContent: gift.audioContent, // Include audioContent for voice gifts
            scheduledDate: gift.scheduledDate,
            deliveryEmail: gift.deliveryEmail,
            occasion: gift.occasion,
          });

          if (giftResult.success) {
            console.log('Gift email sent to recipient after payment:', giftResult.messageId);
          } else {
            console.error('Failed to send gift email after payment:', giftResult.error);
          }
        }
      } catch (giftError) {
        console.error('Error sending gift email after payment:', giftError);
      }
    }

    res.json({ message: 'Payment status updated', order });
  } catch (error) {
    console.error('Error updating payment:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Helper function to determine gift price
function getPrice(giftType) {
  switch (giftType) {
    case 'voice': return 12;
    case 'song': return 25;
    case 'image': return 15;
    case 'illustration': return 15;
    case 'video': return 18;
    case 'poem': return 8;
    case 'wishknot': return 9;
    case 'letter': return 8;
    case 'shortStory': return 10;
    default: return 8;
  }
}

export default router;